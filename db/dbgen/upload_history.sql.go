// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: upload_history.sql

package dbgen

import (
	"context"
	"time"
)

const addUploadHistory = `-- name: AddUploadHistory :exec
INSERT INTO upload_history (file_name, file_size, uploaded_at) VALUES (?, ?, ?)
`

type AddUploadHistoryParams struct {
	FileName   string    `json:"file_name"`
	FileSize   int64     `json:"file_size"`
	UploadedAt time.Time `json:"uploaded_at"`
}

func (q *Queries) AddUploadHistory(ctx context.Context, arg AddUploadHistoryParams) error {
	_, err := q.db.ExecContext(ctx, addUploadHistory, arg.FileName, arg.FileSize, arg.UploadedAt)
	return err
}

const getUploadHistory = `-- name: GetUploadHistory :many
SELECT id, file_name, file_size, uploaded_at FROM upload_history ORDER BY uploaded_at DESC LIMIT ?
`

func (q *Queries) GetUploadHistory(ctx context.Context, limit int64) ([]UploadHistory, error) {
	rows, err := q.db.QueryContext(ctx, getUploadHistory, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UploadHistory{}
	for rows.Next() {
		var i UploadHistory
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FileSize,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trimUploadHistory = `-- name: TrimUploadHistory :exec
DELETE FROM upload_history WHERE id NOT IN (
    SELECT id FROM upload_history ORDER BY uploaded_at DESC LIMIT 100
)
`

func (q *Queries) TrimUploadHistory(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, trimUploadHistory)
	return err
}
